# 06장. 데이터 타입

데이터 타입: 값의 종류
ES6는 7개의 데이터 타입을 제공
ES11에서 1개의 데이터 타입(BigInt) 추가 제공
8개의 데이터 타입은 원시 타입과 객체 타입으로 분류

원시 타입

- 숫자 타입
- 문자열 타입
- 불리언 타입
- undefined 타입
- null 타입
- 심벌 타입
- BigInt 타입
  객체 타입

## 6.1 숫자 타입

모든 수를 실수로 처리
추가적으로 세 가지 값 표현

- `Infinity`
- `-Infinity`
- `NaN`

## 6.2 문자열 타입

텍스트 데이터를 나타내는 데 사용.
다음 표기법을 사용

- 작은따옴표('')
- 큰따옴표("")
- 백틱(\`\`)

## 6.3 템플릿 리터럴

ES6부터 해당 표기법 도입
멀티라인 문자열, 표현식 삽입, 태그드 템플릿 등 문자열 처리 기능 제공
백틱(\`\`)을 사용해 표현

### 6.3.1 멀티라인 문자열

```js
// 일반 문자열
var template = '<ul>\n\t<li><a href="#">Home</a></li>\n</ul>';

// 템플릿 리터럴
var template = `<ul>
  <li><a href="#">Home</a></li>
</ul>`;

/* 출력 결과
<ul>
  <li><a href="#">Home</a></li>
</ul>
*/
```

### 6.3.2 표현식 삽입

```js
var first = "Ung-mo";
var last = "Lee";

// ES5: 문자열 연결
console.log("My name is " + first + " " + last + ".");

// ES6: 표현식 삽입
console.log(`My name is ${first} ${last}.`);

/* 출력 결과
My name is Ung-mo Lee.
*/
```

## 6.4 불리언 타입

논리적 참, 거짓을 나타내는 true와 false 두 가지

## 6.5 undefined 타입

undefined가 유일
변수를 선언한 이후 값을 할당 하지 않으면 암묵적으로 undefined로 초기화

## 6.6 null 타입

null 값이 유일
변수에 값이 없다는 것을 의도적으로 명시할 때 사용

## 6.7 심벌 타입

ES6에서 추가된 7번째 타입
변경 불가능한 원시 타입의 값
다른 값과 절대 중복되지 않은 유일무이한 값
심벌 함수를 호출해 생성

```js
var key = Symbol("key");
```

## 6.8 객체 타입

원시 타입과 객체 타입은 근본적으로 다름
자바스크립트는 객체 기반의 언어이며, 자바스크립트를 이루고 있는 거의 모든 것이 객체

## 6.9 데이터 타입의 필요성

### 6.9.1 데이터 타입에 의한 메모리 공간의 확보와 참조

자바스크립트 엔진은 변수에 할당되는 값의 데이터 타입에 따라 정해진 크기의 메모리 공간을 확보

### 6.9.2 데이터 타입에 의한 값의 해석

모든 값은 메모리에 2진수로 저장
저장된 값은 데이터 타입에 따라 다르게 해석

- 0100 0001 : 숫자로 해석 65, 문자열로 해석 'A'

&nbsp;

**데이터 타입이 필요한 이유**

- 값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정하기 위해
- 값을 참조할 때 한 번에 읽어 들여야 할 메모리 공간의 크기를 결정하기 위해
- 메모리에서 읽어 들인 2진수를 어떻게 해석할지 결정하기 위해

&nbsp;

## 6.10 동적 타이핑

### 6.10.1 동적 타입 언어와 정적 타입 언어

**정적 타입 언어**

- 변수를 선언할 때 할당할 수 있는 데이터 타입을 사전에 선언 (명시적 타입 선언)
- 변수의 타입 변경 불가
- 변수에 선언한 타입에 맞는 값만 할당 가능
- 컴파일 시점에 타입 체크를 수행하여 통과하지 못하면 에러 발생
- C, C++, Java, Kotlin, Go, Haskell, Rust, Scala 등

**동적 타입 언어**

- 변수를 선언할 때 타입을 선언하지 않음
- 변수에 어떠한 데이터 타입의 값이라도 자유롭게 할당
- 값을 할당하는 시점에 변수의 타입이 동적으로 결정
- 선언이 아닌 할당에 의해 타입이 결정 (타입 추론)
- 재할당에 의해 변수의 타입은 언제든지 동적으로 변환 가능 (동적 타이핑)
- JavaScript, Python, PHP, Ruby, Lisp, Perl 등

### 6.10.2 동적 타입 언어와 변수

편리하지만 위험도 존재
동적 타입 언어의 변수는 값을 확인하기 전에는 타입을 확신할 수 없음
높은 유연성, 낮은 신뢰성

# 07장. 연산자

피연산자: 값
연산자: 피연산자를 연산하여 새로운 값을 만듦

## 7.1 산술 연산자

피연산자를 대상으로 수학적 계산을 수행하여 새로운 숫자 값 생성
불가능한 경우 NaN 반환
피연산자의 개수에 따라 이항 산술 연산자와 단항 산술 연산자로 구분

### 7.1.1 이항 산술 연산자

2개의 피연산자를 산술 연산하여 숫자 값을 만듦
피연산자의 값을 변경하는 부수 효과가 없음

이항 산술 연산자

- `+`
  &rarr; 덧셈
- `*`
  &rarr; 곱셈
- `/`
  &rarr; 나눗셈
- `%`
  &rarr; 나머지

### 7.1.2 단항 산술 연산자

1개의 피연산자를 산술 연산하여 숫자 값을 만듦

단항 산술 연산자

- `++`
  &rarr; 증가 (부수 효과 O)
- `--`
  &rarr; 감소 (부수 효과 O)
- `+`
  &rarr; 어떠한 효과 없음
- `-`
  &rarr; 양수를 음수로, 음수를 양수로 반전한 값을 반환

### 7.1.3 문자열 연결 연산자

피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작

- `+`

## 7.2 할당 연산자

우항에 있는 피연산자의 평가 결과를 좌항에 있는 변수에 할당

할당 연산자

- `=`
  &rarr; (부수 효과 O)
- `+=`
  &rarr; (부수 효과 O)
- `-=`
  &rarr; (부수 효과 O)
- `*=`
  &rarr; (부수 효과 O)
- `/=`
  &rarr; (부수 효과 O)
- `%=`
  &rarr; (부수 효과 O)

## 7.3 비교 연산자

좌항과 우항의 피연산자를 비교한 다음 그 결과를 불리언 값으로 반환

### 7.3.1 동등/일치 비교 연산자

좌항과 우항의 피연산자가 같은 값으로 평가되는지 비교해 불리언 값을 반환

- 동등 비교 연산자 &rarr; 느슨한 비교
- 일치 비교 연산자 &rarr; 엄격한 비교

비교 연산자

- `==`
  &rarr; 동등 비교, 값이 같음
- `===`
  &rarr; 일치 비교, 값과 타입이 같음
- `!=`
  &rarr; 부동등 비교, 값이 다름
- `!==`
  &rarr; 불일치 비교, 값과 타입이 다름

### 7.3.2 대소 관계 비교 연산자

피연산자의 크기를 비교하여 불리언 값을 반환

- `>`
- `<`
- `>=`
- `<=`

## 7.4 삼항 조건 연산자

조건식의 평가 결과에 따라 반환할 값을 결정
자바스크립트의 유일한 삼항 연산자

- `조건식 ? 조건식이 true일 때 반환값 : 조건식이 false일 때 반환값`

## 7.5 논리 연산자

우항과 좌항의 피 연산자(부정 논리 연산자의 경우 우항의 피연산자)를 논리 연산

- `||`
  &rarr; 논리합(OR)
- `&&`
  &rarr; 논리곱(AND)
- `!`
  &rarr; 부정(NOT)

## 7.6 쉼표 연산자

왼쪽 피연산자부터 차례대로 피연산자를 평가 후, 마지막 피연산자의 평가가 끝나면 마지막 피연산자의 평가 결과를 반환

- `,`

## 7.7 그룹 연산자

자신의 피연산자인 표현식을 가장 먼저 평가, 따라서 연산자의 우선순위 조절 가능
연산자 우선순위가 가장 높음

- `()`

## 7.8 typeof 연산자

피연산자의 데이터 타입을 문자열로 반환

## 7.9 지수 연산자

ES7에서 도입
좌항의 피연산자를 밑, 우항의 피연산자를 지수로 거듭 제곱하여 숫자 값 반환

- `**`

## 7.10 그 외의 연산자

- `?.`
  &rarr; 옵셔널 체이닝 연산자 (9.4.2절 참고)
- `??`
  &rarr; null 병합 연산자 (9.4.3절 참고)
- `delete`
  &rarr; 프로퍼티 삭제 (10.8절 참고)
- `new`
  &rarr; 생성자 함수를 호출할 때 사용하여 인스턴스를 생성 (17.2.6절 참고)
- `instanceof`
  &rarr; 좌변의 객체가 우변의 생성자 함수와 연결된 인스턴스인지 판별 (19.10절 참고)
- `in`
  &rarr; 프로퍼티 존재 확인 (19.13.1절 참고)

## 7.11 연산자의 부수 효과

일부 연산자는 다른 코드에 영향을 주는 부수 효과가 있다.

- `=`
  &rarr; 할당 연산자
- `++`
  &rarr; 증가 연산자
- `--`
  &rarr; 감소 연산자
- `delete`
  &rarr; delete 연산자

## 7.12 연산자 우선순위

여러 개의 연산자로 이뤄진 문이 실행될 때 연산자가 실행되는 순서

1. `()`
2. `new` (매개변수 존재), `.`, `[]` (프로퍼티 접근), `()` (함수 호출), `?.` (옵셔널 체이닝 연산자)
3. `new` (매개변수 미존재)
4. `x++`, `x--`
5. `!x`, `+x`, `-x`, `++x`, `--x`, `typeof`, `delete`
6. `**`
7. `*`, `/`, `%`
8. `+`, `-`
9. `<`, `<=`, `>`, `>=`, `in`, `instanceof`
10. `==`, `!=`, `===`, `!==`
11. `??` (null 병합 연산자)
12. `&&`
13. `||`
14. `? ... : ...`
15. 할당 연산자(`=`, `+=`, `-=`, `...`)
16. `,`

## 7.13 연산자 결합 순서

연산자의 어느 쪽부터 평가를 수행할 것인지를 나타내는 순서

- 좌향 &rarr; 우향
  `+`, `-`, `/`, `%`, `<`, `<=`, `>`, `>=`, `&&`, `||`, `.`, `[]`, `()`, `??`, `?.`, `in`, `instanceof`
- 우향 &rarr; 좌향
  `++`, `--`, 할당 연산자(`=`, `+=`, `-=`, `...`), `!x`, `+x`, `-x`, `++x`, `--x`, `typeof`, `delete`, `? ... : ...`, `**`
