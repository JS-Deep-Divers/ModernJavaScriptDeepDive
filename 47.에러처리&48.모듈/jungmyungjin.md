# 2023.04.14 자바스크립트 딥다이브 (47.에러처리/48.모듈)

## 기억하고 싶은 내용

### 자바스크립트에서의 에러 처리

- <u>에러에 대해 대처하지 않고 방치하면 프로그램은 강제 종료된다.</u>
- `try...catch`문을 사용해 발생한 에러에 적절하게 대응하면 프로그램이 강제 종료되지 않고 계속해서 코드를 실행시킬 수 있다.
- **`querySelect` 메서드는 인수로 전달한 CSS 선택자 문자열로 DOM에서 요소 노드를 찾을 수 없는 경우 에러를 발생시키지 않고 null을 반환한다.**



### Error 객체

- `try...catch`문의 catch에서 err는 코드 블록에서 발생한 Error객체가 전달된다.
- 자바스크립트는 Error 생성자 함수를 포함해 7가지의 에러 객체를 생성할 수 있는 Error 생성자 함수를 제공한다.
  - 7가지 에러 객체의 프로토타입은 모두 `Error.prototype`을 사속 받는다



### throw 문

- <u>Error 생성자 함수로 에러 객체를 생성한다고 에러가 발생하는 것은 아니다.</u>
  - 즉, 에러 객체 생성과 에러 발생은 의미가 다르다.
- **<u>에러를 발생시키려면 try 코드 블록에서 throw 문으로 에러 객체를 던져야 한다.</u>**
- `throw`문의 표현식은 어떤 값이라도 상관없지만 일반적으로 에러 객체를 지정한다.
  - 에러를 던지면 catch 문의 에러 변수가 생성되고 던져진 에러 객체가 할당된다.

- throw된 에러를 캐치하지 않으면 호출자 방향으로 전파된다.
  - <u>어디에도 캐치하지 않으면 프로그램은 강제 종료된다.</u>
  - 비동기 함수인 setTimeout이나 프로미스 후속 처리 메서드의 콜백 함수는 호출자가 없다는 것이다.



### 모듈

- 모듈이란 애플리케이션을 구성하는 개별적 요소로서 재사용 가능한 코드 조각을 말한다.
- 일반적으로 모듈은 기능을 기준으로 파일 단위로 분리한다.
- 이때 <u>모듈이 성립하려면 모듈은 자신만의 **파일 스코프(모듈 스코프)**를 가질 수 있어야 한다.</u>



### 모듈 스코프

- ES6(ESM)은 독자적인 모듈 스코프를 갖는다. ESM이 아닌 일반적인 자바스크립트 파일은 script 태그로 분리해서 로드해도 독자적인 모듈 스코프를 갖지 않는다.
- **<u>script 태그로 분리해서 로드된 2개의 자바스크립트 파일은 하나의 자바스크립트 파일 내에 있는 것처럼 동작한다.</u>**
- ESM은 파일 자체의 독자적인 모듈 스코프를 제공한다. 따라서 모듈 내에서 **var** 키워드로 선언한 변수는 더는 지역 변수가 아니며 **window** 객체의 프로퍼티도 아니다.



### export

- 모듈 내부에서 선언한 식별자를 외부에 공개하여 다른 모듈들이 재사용할 수 있게 할 때 사용한다.
- 공개된 모듈의 자산은 다른 모듈에서 재사용할 수 있다.



### import

- 다른 모듈에서 공개(export)한 식별자를 자신의 모듈 스코프 내부로 로드할 때 사용한다.

- 다른 모듈이 export한 식별자 이름으로 import 해야 하며, ESM의 경우 파일 확장자를 생략할 수 없다.

- `import * as lib from './libs.mjs'` : lib.mjs 모듈이 export한 모든 식별자를 lib 객체의 프로퍼티로 모아 import 한다.

- 하나의 값만 export 한다면 default 키워드를 사용할 수 있다.

  



## 느낀점

- 모듈과 에러의 이론에 대해서 다시금 정리해 볼 수 있는 장 이었다.
- 오늘로써 자바스크립트 딥다이브 책 읽기 스터디는 끝난다..
- 마지막 두 장은 가벼워서 읽기 수월하였다.
- 5주간.... 고생했다....  나...🥹



