# 2023.03.24_자바스크립트 딥다이브 (20.strict mode/21.빌트인 객체/22.this)

## 기억하고 싶은 내용

### 암묵적 전역

```javascript
function foo(){
  x = 10;
}
foo();

console.log(x); // ?
```

- 실행 결과로 x 변수의 선언이 존재하지 않기 때문에 `ReferenceError`를 발생시킬 것 같지만, 자바스크립트 엔진은 암묵적으로 전역 객체에 x프로퍼티를 동적 생성하기 때문에 x의 결과값이 출력된다.
  - 이때 전역 객체 x 프로퍼티는 마치 전역 변수처럼 사용할 수 있다. 이를 **암묵적 전역**이라 한다.
- 암묵적 전역은 오류를 발생시키는 원인이 될가능성이 크기 때문에 반드시 변수 키워드를 선언 후 사용해야 한다.



### strict mode

`사용 법` : 전역의 선두 또는 함수 몸체의 선두에 `user strict;`를 추가한다.



**주의 할 점**

- 전역에 `strict mode`를 적용하는 것은 피하자.
- 함수 단위로 `strict mode`를 적용하는 것도 피하자



### strict mode에서 발생되는 현상

1. `delete 연산자`로 변수, 함수, 매개변수를 삭제하면 `SyntaxError`가 발생한다.
2. 매개변수의 이름을 삭제하면  `SyntaxError`가 발생한다.
3. with문을 사용하면  `SyntaxError`가 발생한다.
4. 함수를 일반 함수로서 호출하면 `this`에 `undefined`가 바인딩 된다.
5. 매개변수에 전달된 인수를 재할당하여 변경해도 `argument 객체`에 반영되지 않는다.



### 자바스크립트 객체의 분류

-  **표준 빌트인 **
  - ECMAScript 사양에 정의된 객체
- **호스트 객체**
  - ECMAScript 사양에는 정의되어 있지 않지만 자바스크립트 실행환경(브라우저 환경/Node.js 환경)에서 추가로 제공하는 객체를 말한다.
- **사용자 정의 객체**
  - 사용자가 직접 정의



### 래퍼 객체

**원시값은 객체가 아니므로 프로퍼티나 메서드를 가질 수 없는데도 원시값이 문자열은 마치 객체처럼 동작한다**

- 원시 값인 문자열, 숫자, 불리언 값의 경우 이들 원시값에 대해 마치 객체처럼 마침표 표기법으로 접근하면 자바스크립트 엔진이 일시적으로 원시값을 연관된 객체로 변환해 주기 때문이다.

- 즉, 원시값을 객체처럼 사용하면 자바스크립트 엔진은 암묵적으로 연관된 객체를 생성하여 객체로 프로퍼티에 접근하거나 메서드를 호출하고 다시 원시값으로 되돌린다.

  **이처럼 문자열, 숫자, 불리언 값에 대해 객체처럼 접근하면 생성되는 임시 객체를 래퍼 객체라 한다**



### This

객체에서 동작을 나타내는 메서드는 자신이 속한 객체의 상태, 즉 프로퍼티를 참조하고 변경할 수 있어야 한다.
이때 메서드가 자신이 속한 객체의 프로퍼티를 참조하려면 먼저 **자신이 속한 객체를 가리키는 식별자를 참조할 수 있어야 한다.** 
이를 위해 사용하는 키워드가 `this`이다.

- `this`는 자바스크립트 엔진에 의해 암묵적으로 생성된다.
- 함수를 호출하면 `arguments`객체와 `this`가 암묵적으로 함수 내부에 전달된다.
- `this`가 가리키 값, 즉  `this 바인딩`은 함수 호출 방식에 의해 동적으로 결정된다.



**this 바인딩**

- 변수 선언은 변수 이름과 확보된 메모리 공간의 주소를 바인딩하는 것이다.
- `this바인딩`은 `this`와 `this가 가리킬 객체`를  바인딩 하는 것이다.
- `strict mode` 역시 `this 바인딩`에 영향을 준다.



**일반 함수 내부의 this**

- this는 객체의 프로퍼티나 메서드를 참조하기 위한 자기 참조 변수이므로 일반적으로 객체의 내부 또는 생성사 함수 내부에서만 의미가 있다.
- 따라서 `strict mode`가 적용된 일반 함수 내부의 `this`에는 `undefined`가 바인딩 된다.
  - 일반 함수 내부에서 `this`를 사용할 필요가 없기 때문이다.



### 함수 호출 방식과 this 바인딩

**일반 함수 호출**

- 일반 함수 호출 내부의 this - 전역 객체 바인딩
  - 일반함수로 호출된 모든(중첩, 콜백 함수 포함) 내부의 `this`에는 전역 객체가 바인딩된다.
- **<u>화살표 함수 내부의 `this`는 상위 스코프의 `this`를 가리킨다</u>**



**메서드 호출**

- 메서드 호출 내부의 this 메서드를 호출한 객체를 바인딩



**생성자 함수 호출**

- 생성자 함수 내부의 this - 미래에 생성할 인스턴스가 바인딩



**Function.prototype.apply/call/bind 메서드에 의한 간접 호출**

- Function.prototype.apply/call/bind 메서드에 첫번째 인수로 전달한 객체 바인딩





## 느낀점

- 언젠가 강의를 들을 때, 좋은 습관을 들이기 위해 `strict` 모드를 사용할 것을 권하는 내용을 들었었다.
- 엄격한 모드라 에러가 많이 생기는 부분은 짐작하였지만, 동작 자체의 차이가 나는 것도 있는 부분은 처음 알았다.
- 에러가 생길 수 있는 부분이라, 알아둬야 할 것 같다.
- 빌트인 객체는 알고 있던 부분이 꽤 있어서 술술 읽었다.
- 자바스크립트 코드를 짜면서 알 수 밖에 없는 부분인 것 같다.
- 래퍼 객체의 설명 부분은 당연스레 이해했던 부분인데, 생각해보니 간과했던 부분이라 놀랐다.
- this 부분은 단순하긴 하나, 코드에 쓸 때 마다 헷깔리는 내용이다. 아마 실제로 사용해 본 경험이 적어서 그런것 같다. 따로 정리해두고 사용할 때 마다 확인해야 겠다.