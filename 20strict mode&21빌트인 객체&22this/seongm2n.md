### 20장

[20.1] strict mode란?

- 자바스크립트 언어의 문법을 좀 더 엄격히 적용하여 오류를 발생시킬 가능성이 높거나

    자바스크립트 엔진의 최적화 작업에 문제를 일으킬 수 있는 코드에 대해 명시적인 에러를 발생시킴


[20.2] strict mode의 적용

- 전역의 선두 또는 함수 몸체의 선두에 ‘use strict’;를 추가
    - 전역 선두 : 스크립트 전체에 적용
    - 함수 선두 : 해당 함수와 중첩 함수에 적용

[20.3] 전역에 strict mode를 적용하는 것은 피하자

- 스크립트 단위로 적용된 strict mode는 다른 스크립트에 영향을 주지 않고 해당 스크립트에 한정되어 적용

[20.4] 함수 단위로 strict mode를 적용하는 것도 피하자

- 모든 함수에 일일이 strict mode를 적용하는 것은 번거로운 일
- strict mode가 적용된 함수가 참조할 외부의 컨텍스트에 strict mode를 적용하지 않는다면 이 또한 문제 발생

[20.5] strict mode가 발생시키는 에러

(1) 암묵적 전역

- 선언하지 않은 변수를 참조했을 때

(2) 변수, 함수, 매개변수의 삭제

- delete연산자로 변수,함수,매개변수를 삭제했을 때

(3) 매개변수 이름의 중복

- 중복된 매개변수 이름을 사용했을 때

(4) with문의 사용

- with문을 사용하면 발생 → 성능과 가독성이 나빠지는 문제

[20.6] strict mode 적용에 의한 변화

(1) 일반 함수의 this

- 일반 함수로서 호출하면 this에 undefined가 바인딩
- 생성자 함수가 아님 일반 함수 내부에서는 this를 사용할 필요 없음 → 이때 에러는 발생하지 않음

(2) arguments 객체

- 매개변수에 전달된 인수를 재할당해서 변경해도 arguments객체에 반영되지 않음

### 21장

✅ 자바스크립트 객체의 분류

[1] 표준 빌트인 객체 → Object, String, Number, Boolean, Symbol, Date………등등 40여개 제공

- Math,Reflect, JSON을 제외한 표준 빌트인 객체는 모두 인스턴스를 생성할 수 있는 생성자 함수 객체

[2] 호스트 객체

[3] 사용자 정의 객체

[21.3] 원시 값과 래퍼 객체

- 문자열, 숫자, 불리언 값에 대해 객체처럼 접근하면 생성되는 임시 객체를 래퍼 객체라 함

[21.4] 전역 객체

- 코드가 실행되기 이전 단계에서 자바스크립트 엔진에 의해 어떤 객체보다도 먼저 생성되는 특수한 객체, 어떤 객체에도 속하지 않은 최상위 객체
    - 브라우저 환경 → window(또는 self,this,framed)
    - Node.js환경 → global

    (1) 빌트인 전역 프로퍼티

    - 전역 객체의 프로퍼티를 의미
    - 주로 애플리케이션 전역에서 사용하는 값 제공

        <Infinity>

        <NaN>

        <undefined>


    (2) 빌트인 전역 함수

    - 애플리케이션 전연에서 호출할 수 있는 빌트인 함수로 전역 객체의 메서드

    <eval>

    💣 보안이 매우 취약하고 최적화 안되고 일반적인 코드 실행에 비해 처리 속도가 느려서 eval함수의 사용은 금지 !!!!!

    <isFinite>

    <isNaN>

    <parseFloat>

    <parseInt>

    <encodeURI / decodeURI>

    - encodeURI함수 → 완전한 URI를 문자열로 전달당아 이스케이프 처리를 위해 인코딩
    - decodeURI함수 → 인코딩된 URI를 인수로 전달받아 이스케이프 처리 이전으로 디코딩

    <encodeURIComponent / decodeURIComponent>

    [21.4.3] 암묵적 전역

    ```jsx
    var x = 10;
    function foo(){
    	y = 20; //window.y로 식별
    }
    foo();
    console.log(x + y); //30
    ```

    → foo 함수가 호출되면 자바스크립트 엔진은 y변수에 값을 할당하기 위해 먼저 스코프 체인을 통해 선언된 변수인지 확인

    → 이때 foo함수의 스코프와 전역 스코프 어디에도 y변수의 선언을 찾을 수 없으므로 참조 에러가 발생

    → 하지만 자바스크립트 엔지은 y=20을 window.y=20으로 해석하여 전역 객체에 프로퍼티를 동적 생성

    → 이러한 현상을 암묵적 전역

    → y는  변수가 아니다. y는 변수가 아니므로 변수 호이스팅이 발생하지는 않음

    → y는 delete연산자로 삭제 할 수 있지만 전역 변수 x는 삭제되지 않음


### 22장

[22.1] this 키워드

- 메서드가 자신이 속한 객체의 프로퍼티를 참조하려면 먼저 자신이 속한 객체를 가리키는 식별자를 참조할 수 있어야 함
- this는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수
- this를 통해 자신이 속한 객체 또는 자신이 생성할 인스턴스의 프로퍼티나 메서드를 참조할 수 있음
- this가 가리키는 값, 즉 this바인딩은 함수 호출 방식에 의해 동적으로 결정
    - this 바인딩 : 식별자와 값을 연결하는 과정
        - (예) 변수 선언은 변수 이름과 확보된 메모리 공간의 주소를 바인딩 하는 것, this바인딩은 this와 this가 가리킬 객체를 바인딩

[22.2] 함수 호출 방식과 this바인딩

- this바인딩은 함수 호출 방식, 즉 함수가 어떻게 호출되었는지에 따라 동적으로 결정
- 함수 호출 방식
    1. 일반 함수(중첩,콜백) 호출 : 기본적으로 this에는 전역 객체가 바인딩
    2. 메서드 호출 : 메서드 호출할 때 메서드 이름 앞의 마침표(.)연산자 앞에 기술한 객체가 바인딩
    3. 생성자 함수 호출 : 생성자 함수 내부의 this에는 생성자 함수가 (미래에) 생성할 인스턴스가 바인딩
    4. Function.prototype.apply/call/bind메서드에 의한 간접 호출 : apply, call, bind메서드는 Function.prototype의 메서드, 즉 이들 메서드는 모든 함수가 상속받아 사용
        - apply 메서드 → 호출할 함수의 인수를 배열로 묶어 전달
        - call 메서드 → 호출할 함수의 인수를 쉼포로 구분한 리스트 형식으로 전달

        | 함수 호출 방식 | this 바인딩 |
        | --- | --- |
        | 일반 함수 호출 | 전역 객체 |
        | 메서드 호출 | 메서드를 호출한 객체 |
        | 생성자 함수 호출 | 생성자 함수가(미래에)생성할 인스턴스 |
        | Function.prototype.apply/call/bind 메서드에 의한 간접 호출 | Function.prototype.apply/call/bind 메서드에 첫번쨰 인수로 전달한 객체 |
