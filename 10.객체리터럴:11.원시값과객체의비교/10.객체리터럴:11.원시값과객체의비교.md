# 10장 객체 리터럴 / 11장 원시값과 객체의 비교

> 새롭게 알게된 내용을 정리합니다.

<br>

## **10장 객체 리터럴**

### 10.1 객체란?

```
- 자바스크립트를 구성하는 거스이 "모든 것"이 객체이다.
- 원시 값을 제외한 나머지 값(함수, 배열, 정규 표현식 등)은 모두 객체다.
- 원시 값은 변경 불가능한 값이지만 객체는 변경 가능한 값이다.
- 객체는 0개 이상의 프로퍼티로 구성된 집합이며, 프로퍼티는 키와 값으로 구성된다.
```

<br>

### 10.2 객체 리터럴에 의한 객체 생성

```
- 객체 리터럴의 중괄호는 코드 블럭을 의미하지 않는다.
- 코드 블럭의 닫는 중괄호(if문, 함수 등등) 뒤에는 세미콜론을 붙이지 않는데, 객체 리터럴의 중괄호에는 세미클론이 붙는다.
```

<br>

### 10.3 프로퍼티

> 객체는 프로퍼티의 집합이다. 프로퍼티는 키와 값으로 구성된다.

```js
var person = {
  //프로퍼티 키는 name, age, 값은 'Lee', 20
  name: 'Lee',
  age: 20,
};
```

- 프로퍼티 키 : 빈 문자열을 포함하는 모든 문자열 또는 심벌 값
- 프로퍼티 값 : 자바스크립트에서 사용할 수 있는 모든 값

```js
var person = {
  firstName: 'Ung-mo',
  'last-name': 'Lee',
};
```

- 프로퍼티 키 이름을 정할 때 식별자 네이밍 규칙을 따르지 않을 경우 반드시 따옴표를 사용해야 함

```js
var foo = {
  0: 1,
  1: 2,
  2: 3,
};

console.log(foo); // {0:1, 1:2, 2:3}
```

- 암묵적 타입 변환으로 키가 문자열로 변환된다.

<br>

### 10.5 프로퍼티 접근

```js
var person = {
    name : 'Lee';
};

console.log(person[name]) // ReferenceError : name is not defined

console.log(person.age) // undefined
```

- 대괄호 표기법을 사용하는 경우 대괄호 프로퍼티 접근 연산자 내부에 지정하는 프로퍼티 키는 반드시 따옴표로 감싼 문자열이어야 함.
  - 따옴표로 감싸지 않는 경우 식별자로 인식
  - 에러가 나는 이유는 식별자 name을 찾지 못했기 때문
- 객체에 존재하지 않는 프로퍼티 접근 시 undefined 반환

<br>

### 10.8 프로퍼티 삭제

```js
var person = {
  name: 'Lee',
};

person.age = 20;
delete person.age; //age 프로퍼티 삭제
```

<br>

### 10.9.1 프로퍼티 축약 표현

```js
let x = 1,
  y = 2;
const obj = { x, y };
console.log(obj); // {x : 1, y : 2}
```

- 변수이름과 프로퍼티 키가 동일한 이름일 때 프로퍼티 키 생략 가능
- 이 때 프로퍼티 키는 변수 이름으로 자동생성

<br>

### 10.9.3 메서드 축약 표현

```js
const obj = {
  name: 'Lee',
  sayHi() {
    console.log('Hi! ' + this.name);
  },
};

obj.sayHi();
```

- function() 키워드를 생략하고 축약 가능

<br>

## **11장. 원시 값과 객체의 비교**

> 원시값을 변수에 할당하면 변수(확보된 메모리 공간)에는 실제 값이 저장된다. 이에 비해 객체를 변수에 할당하면 변수에는 참조 값이 저장된다.

### 11.1.1 변경 불가능한 값

- 원시 타입의 값, 원시 값은 변경 불가능한 값
- 여기서 값 변경이 불가능하다는 이야기는 원시 값 자체를 변경할 수 없다는 것이지 변수 값을 변경할 수 없다는 말이 아니다.
  - 즉 변수의 재할당은 가능하다는 것.
  - 단 상수는 재할당도 불가능하다.
- 변수에 값이 재할당 되면 새로운 메모리 공간이 생기게 됨. 그리고 새로운 메모리 공간을 가리킴
  - 즉, 같은 메모리 공간 안의 값이 변경 불가능 하다는 것.
  - 만약 원시 값이 변경가능했다면 동일 메모리 공간에서 80->90으로 변경됨.

<br>

### 11.1.2 문자열과 불변성

> 자바스크립트에서 문자열을 원시타입 중 하나다. 사용자의 편의를 위해 그렇게 지정

```js
var str = 'string';

str[0] = 'S';

console.log(str); // string
```

- string은 배열과 유사하게 인덱스 접근이 가능하고, length 프로퍼티를 가지지만 원시타입이다. 따라서 str[0] = 'S'와 같이 값을 바꾸는 것이 불가능하다.(재할당은 물론 가능)

<br>

### 11.1.3 값에 의한 전달

```js
var score = 80;
var copy = score;

console.log(score);
console.log(copy);

score = 100;

console.log(score); //100
console.log(copy); //80
```

_score는 100, copy는 80인 이유는?_

- score 변수가 가리키는 메모리 공간에 저장된 80이라는 값을 복사하여 copy가 가리키는 새로운 메모리 공간에 저장된다. 그 후 score에 100을 재할당 했기에 또 다시 새로운 메모리 공간이 생성되고 100이 저장되며, 그 곳을 score 변수가 가리킨다.
- copy 변수와는 별개의 메모리 공간을 사용하기 때문에 copy 값은 80으로 유지되는 것.
- 다만 엄밀히 말하자면 값이 전달되는 것은 아니며 메모리 주소가 전달되는 것이다. 변수와 같은 식별자는 값이 아니라 메모리 주소를 기억하기 때문이다.

<br>

### 참조에 의한 전달

```js
var person = {
  name: 'Lee',
};

// 참조 값을 복사(얉은 복사)
var copy = person;
```

- 객체를 복사하게 되면(얉은 복사 시에) 원본의 참조 값이 복사된다.
- 객체는 객체를 할당한 변수를 참조하면 메모리에 저장되어 있는 참조 값을 통해 실제 객체에 접근한다.
- 따라서 copy에는 person이 가리키는 메모리 공간에 들어있는 메모리 주소(실제 객체가 들어있는 주소)가 담기게 된다. 즉 copy와 person이 가리키는 메모리 공간에는 동일한 값이 들어있다.
- 때문에 copy에서 프로퍼티 값을 변경하면 이는 person에도 적용된다.
