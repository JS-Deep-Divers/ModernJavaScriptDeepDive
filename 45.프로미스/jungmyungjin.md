# 2023.04.12 자바스크립트 딥다이브 (45.프로미스)

## 기억하고 싶은 내용



### 비동기 함수

- 함수 내부의 비동기로 동작하는 코드는 비동기 함수가 종료된 이후에 완료된다.
- 따라서 비동기 함수 내부의 비동기로 동작하는 코드에서 처리 결과를 외부로 반환하거나 상위 스코프의 변수에 할당하면 기대한 대로 동작하지 않는다.

- 비동기 함수는 비동기 처리 결과를 외부에 반환할 수 없고, 상위 스코프의 변수에 할당할 수도 없다.
  - 따라서 비동기 함수의 처리결과에 대한 후속 처리는 비동기 함수 내부에서 수행해야 한다.
  - 이때 비동기 함수를 범용적으로 사용하기 위해 비동기 함수에 비동기 처리 결과에 대한 후속 처리를 수행하는 콜백 함수를 전달하는 것이 일반적이다.



**콜백 헬**

- 콜백 함수 호출이 중첩되어 복잡도가 높아지는 현상



### 비동기 처리를 위한 콜백 패턴의 한계

- 에러는 콜 스택의 아래 방향(실행 중인 실행 컨텍스트가 푸시되기 직전에 푸시된 실행 컨텍스트 방향)으로 전파된다.
- 하지만 예를들어 setTimeout 함수의 콜백 함수가 에러를 발생시킨다고 했을 때 catch 블록에서 캐치되지 않는다.



### 프로미스

- 콜백 패턴의 **콜백 헬**과 **에러 처리 문제** 떄문에 ES6에서 프로미스가 도입되었다.

- 프로미스 생성 직후 기본적으로 `pending` 상태이다.

  이후 비동기 처리가 수행되면 결과에따라 `fulfilleed` / `rejected` 상태로 변경된다.

  

### 프로미스 후속처리 메서드

- `then` 
  - 두개의 콜백 함수(호출 성공 콜백함수/호출 실패 콜백함수)를 는다.
- `catch`
  - 한개의 콜백 함수를 인수로 받는다
  - catch 메서드의 콜백함수는 프로미스가 rejected 상태인 경우에만 호출된다.
  - 프로미스의 에러처리에 사용되며 모든 then 이후에 호출하면 비동기 처리에서 발생한 에러 뿐만 아니라 then 메서드 내부에서 발생한 에러까지 모두 캐치할 수 있다.
- `finally`
  - 한개의 콜백 함수를 인수로 받는다.
  - finally 메서드의 콜백함수는 프로미스의 성공/실패 여부 상관없이 무조건 한번 호출된다.



## 프로미스 정적 메서드

- `resolve`/`reject`

  ```javascript
  const resolvedPromise = Promise.resolve([1, 2, 3]);
  // 위 코드는 아래 코드와 동일하게 동작한다.
  const resolvedPromise = new Promise(resolve => resolve([1, 2, 3]))
  
  const resolvedPromise = Promise.reject(new Error('Error!'));
  // 위 코드는 아래 코드와 동일하게 동작한다.
  const resolvedPromise = new Promise((_, reject) => reject(new Error('Error!'));
  ```

- `Promise.all`

  - 여러 개의 비동기 처리를 모두 병렬 처리할 때 사용 한다.
  - 인수로 전달받은 배열의 <u>모든 프로미스가 **fulfilled** 상태가 되면 종료한다.</u>
  - 전달받은 배열의 프로미스가 하나라도 **rejected** 상태가 되면 즉시 종료한다.

- `Promise.race`

  - 인수로 전달받은 배열의 모든 프로미스 중 가장 먼저 fulfilled 상태가 된 프로미스의 처리 결과를 **resolve** 하는 새로운 프로미스를 반환한다.
  - 전달받은 배열의 프로미스가 하나라도 **rejected** 상태가 되면 즉시 종료한다.

- `Promise.allSettled`

  - 전달받은 프로미스가 모두 settled 상태(비동기 처리가 수행된 상태, 즉 fulfilled 또는 rejected 상태)가 되면 처리 결과를 배열로 반환한다.



### 마이크로태스크 큐

- 마이크로태스크 큐는 태스크 큐보다 우선순위가 높다.
- 프로미수의 후속처리 메서드의 콜백 함수는 태스크 큐가 아니라 마이크로태스크 큐에 저장된다.



### fetch

- HTTP 요청 전송 기능을 제공하는 클라이언트 사이드 Web API 이다.
- `fetch` 함수는 `XMLHttpRequest` 객체보다 사용법이 간단하고 프로미스를 지원하기 때문에 비동기 처리를 위한 콜백 패턴의 단점에서 자유롭다.
- fetch 함수는 HTTP 응답을 나타내는 Response  객체를 래핑한 프로미스를 반환하므로 후속 처리 메서드 `then`을 통해 프로미스가 **resolve**한 **Response 객체**를 전달받을 수 있다.
- fetch 함수가 반환하는 프로미스는 `404` `500` 과같은 HTTP 에러가 나발생해도 에러를 `reject`하지 않고 불리언 타입의 ok 상태를 false로 설정한 Response 객체를 resolve 한다.





## 느낀점

- 이전에 앨리스에서 프로미스 관련 내용을 공부했을 때 이해가 되지 않은 부분이 있어 읽었었다.
- 3주 정도 뒤에 읽은 것 같은데, 헷깔렸던 내용을 다시 읽어서 좋았다.
- 개념적으론 대략적으로 머리에 남은 상태라, 앞으로 실습을 해보면 더 이해가 될 것 같다.
- 중요한 내용을 다시 읽으니 좋다.

