# 자바스크립트 딥다이브 13. 스코프

## 기억하고 싶은 내용

- `var` 키워드로 선언한 변수와 `let` 또는  `const`키워드로 선언한 변수의 스코프도 다르게 동작한다.



### 렉시컬 환경(lexical environment)

- 코드가 어디서 실행되며 주변에 어떤 코드가 있는지를 렉시컬 환경이라고 부른다.
- 코드의 문맥(context)는 렉시컬 환경으로 이뤄진다. 이를 구현한 것이 실행 컨텍스트(excution context)이며, 모든 코드는 실행 컨텍스트에서 평가되고 실행된다.



- var키워드로 선언된 변수는 같은 스코프 내에서 중복 선언이 허용된다. 이는 의도치 않게 변수값이 재할당되어 변경되는 부작용을 발생시킨다.

  ```javascript
  function foo (){
  	var x = 1;
  	var x = 2; // 이때 자바스크립트 엔진에 의해 var 키워드가 없는 것처럼 동작한다.
  }
  ```



### 스코프 체인(scope chain)

- 모든 스코프는 하나의 계층적 구조로 연결되며, 모든 지역 스코프의 최상위 스 코프는 전역 스코프다. 이렇게 스코프가 계층적으로 연결된 것을 스코프 체인이라 한다.
- 변수를 참조할 때 자바스크립트 엔진은 스코프 체인을 통해 변수를 참조하는 코드의 스코프에서 시작하여 상위 스코프 방향으로 선언된 변수를 검색한다.
- 스코프 체인은 물리적인 실체로 존재한다. 자바스크립트 엔진은 코드(전역 코드와 함수 코드)를 실행하기에 앞서 위 그림과 유사한 자료구조인 렉시컬 환경(Lexical Environment)을 실제로 생성한다.
  - 변수 선언이 실행되면 변수 식별자가 `렉시컬 환경의 자료구조`에 key로 등록되고
  - 변수 할당이 일어나면 `렉시컬 환경의 자료구조`에 해당하는 값을 변경한다.
  - 변수의 검색도 이 자료구조 상에서 이뤄진다.



### 함수 레벨 스코프

- `var`키워드로 선언된 변수는 오로지 함수의 코드 블록(함수 몸체)만을 지역 스코프로 인정한다. 이를 **`함수 레벨 스코프(function level scope)`**라 한다.

- `var` 로 선언된 변수는 오로지 **함수의 코드 블록만을 지역 스코프로 인정**하지만 ES6에서 도입된 `let`, `const` 키워드는 **블록 레벨 스코프를 지원**한다.



### 렉시컬 스코프

**동적 스코프(dynamic scope)**

- **함수를 어디서 <u>호출</u>**했는지에 따라 함수의 상위 스코프를 결정한다.
- 함수를 정의하는 시점에는 함수가 어디서 호출될지 알 수 없다. 따라서 함수가 호출되는 시점에 동적으로 상위 스코프를 결정해야 하기 때문에 동적 스코프라 부른다.



**렉시컬 스코프(lexical scope)/정적 스코프**

- **함수를 어디서 <u>정의</u>**했는지에 따라 함수의 상위 스코프를 결정한다.
- **함수 정의가 평가되는 시점에 상위 스코프가 정적으로 결정**되기 때문에 함수가 호출된 위치는 상위 스코프 결정에 어떠한 영향도 주지 않는다.

- <u>자바스크립트의는 렉시컬 스코프를 따른다.</u>





## 느낀점

- 헷깔리는 개념이 있던 장이다. `var` 과 `let`, `const`의 차이에 대해 알게 되었다
  - => `var` : 함수 레벨 스코프
  - => `let`, `const` : 블록 레벨 스코프
  - 이에 대한 동작방식의 차이가 큰 것 같다.
- 렉시컬 스코프는 좀 의외였다. 동적 스코프로 동작할 것이라고 막연하게 짐작하고 있었기 때문이다, 놀랐긴 했지만 글을 읽을 수록 렉시컬 스코프에 대한 코드 동작방식이 더 이해가 잘 될 것 같다.



# 자바스크립트 딥다이브 (23.실행 컨텍스트)

## 기억하고 싶은 내용

- `var` 키워드로 선언한 변수와 `let` 또는  `const`키워드로 선언한 변수의 스코프도 다르게 동작한다.



### 렉시컬 환경(lexical environment)

- 코드가 어디서 실행되며 주변에 어떤 코드가 있는지를 렉시컬 환경이라고 부른다.
- 코드의 문맥(context)는 렉시컬 환경으로 이뤄진다. 이를 구현한 것이 실행 컨텍스트(excution context)이며, 모든 코드는 실행 컨텍스트에서 평가되고 실행된다.



- var키워드로 선언된 변수는 같은 스코프 내에서 중복 선언이 허용된다. 이는 의도치 않게 변수값이 재할당되어 변경되는 부작용을 발생시킨다.

  ```javascript
  function foo (){
  	var x = 1;
  	var x = 2; // 이때 자바스크립트 엔진에 의해 var 키워드가 없는 것처럼 동작한다.
  }
  ```



### 스코프 체인(scope chain)

- 모든 스코프는 하나의 계층적 구조로 연결되며, 모든 지역 스코프의 최상위 스 코프는 전역 스코프다. 이렇게 스코프가 계층적으로 연결된 것을 스코프 체인이라 한다.
- 변수를 참조할 때 자바스크립트 엔진은 스코프 체인을 통해 변수를 참조하는 코드의 스코프에서 시작하여 상위 스코프 방향으로 선언된 변수를 검색한다.
- 스코프 체인은 물리적인 실체로 존재한다. 자바스크립트 엔진은 코드(전역 코드와 함수 코드)를 실행하기에 앞서 위 그림과 유사한 자료구조인 렉시컬 환경(Lexical Environment)을 실제로 생성한다.
  - 변수 선언이 실행되면 변수 식별자가 `렉시컬 환경의 자료구조`에 key로 등록되고
  - 변수 할당이 일어나면 `렉시컬 환경의 자료구조`에 해당하는 값을 변경한다.
  - 변수의 검색도 이 자료구조 상에서 이뤄진다.



### 함수 레벨 스코프

- `var`키워드로 선언된 변수는 오로지 함수의 코드 블록(함수 몸체)만을 지역 스코프로 인정한다. 이를 **`함수 레벨 스코프(function level scope)`**라 한다.

- `var` 로 선언된 변수는 오로지 **함수의 코드 블록만을 지역 스코프로 인정**하지만 ES6에서 도입된 `let`, `const` 키워드는 **블록 레벨 스코프를 지원**한다.



### 렉시컬 스코프

**동적 스코프(dynamic scope)**

- **함수를 어디서 <u>호출</u>**했는지에 따라 함수의 상위 스코프를 결정한다.
- 함수를 정의하는 시점에는 함수가 어디서 호출될지 알 수 없다. 따라서 함수가 호출되는 시점에 동적으로 상위 스코프를 결정해야 하기 때문에 동적 스코프라 부른다.



**렉시컬 스코프(lexical scope)/정적 스코프**

- **함수를 어디서 <u>정의</u>**했는지에 따라 함수의 상위 스코프를 결정한다.
- **함수 정의가 평가되는 시점에 상위 스코프가 정적으로 결정**되기 때문에 함수가 호출된 위치는 상위 스코프 결정에 어떠한 영향도 주지 않는다.

- <u>자바스크립트의는 렉시컬 스코프를 따른다.</u>





## 느낀점

- 헷깔리는 개념이 있던 장이다. `var` 과 `let`, `const`의 차이에 대해 알게 되었다
  - => `var` : 함수 레벨 스코프
  - => `let`, `const` : 블록 레벨 스코프
  - 이에 대한 동작방식의 차이가 큰 것 같다.
- 렉시컬 스코프는 좀 의외였다. 동적 스코프로 동작할 것이라고 막연하게 짐작하고 있었기 때문이다, 놀랐긴 했지만 글을 읽을 수록 렉시컬 스코프에 대한 코드 동작방식이 더 이해가 잘 될 것 같다.





# 자바스크립트 딥다이브 23. 실행 컨텍스트

*실행 컨텍스트는 자바스크립트의 동작 원리르 담고 있는 핵심 개념이다*



### `ECMAScript code`의 4가지 타입

- **전역 코드(global code)**
  - 전역에 존재하는 소스코드
  - 전역에 정의된 함수, 클래스의 내부 코드는 포함하지 않는다.
- **함수 코드(function code)**
  - 함수 내부에 존재하는 소스코드
  - 함수 내부에 중첩된 함수, 클래스 등의 내부 코도는 포함되지 않는다.
- **eval 코드(eval code)**
  - 빌트인 전역함수인 `eval 함수`에 인수로 전달되어 실행되는 소스코드를 말한다
- **모듈 코드(module code)**
  - 모듈 내부에 존재하는 소스코드를 말한다.
  - 모듈 내부의 함수, 클래스 등의 내부 코드는 포함되지 않는다.



### 전역 코드

- 전역 코드는 **전역 변수를 관리하기 위해 최상위 스코프인 전역 스코프를 생성해야 한다.** 
- 그리고 **`var`키워드로 선언된 전역 변수와 함수 선언문으로 정의된 전역 함수**를 전역 객체의 프로퍼티와 메서드로 바인딩 하고 참조하기 위해 **전역 객체와 연결**되어야 한다.
- 이를 위해 **전역 코드가 평가되면 전역 실행 컨텍스트가 생성**된다.



### 함수 코드

- 함수 코드는 **지역 스코프를 생성하고 지역 변수, 매개변수, arguments 객체를 관리**해야 한다.
- 그리고 **생성한 지역 스코프를** 전역 스코프에서 시작하는 **스코프 체인의 일원으로 연결**해야 한다.
- 이를 위해 **함수 코드가 평가되면 함수 실행 컨텍스트가 생성**된다.



### 소스코드의 평가와 실행

**소스코드 평가 과정**

1. 실행 컨텍스트를 생성한다
2. `변수`, `함수` 등의 <u>선언문</u>만 먼저 실행하여, `생성된 변수`나 `함수 식별자`를 키(key)로 실행컨텍스트가 관리하는 `스코프(렉시컬 환경의 환경 레코드)`에 등록한다.



**소스코드의 실행**

1. 소스코드의 평가가 끝나면 <u>선언문을 제외한 소스코드</u>가 순차적으로 실행되기 시작한다.
2. 이때 소스코드 실행에 <u>필요한 정보(변수나 함수의 참조)</u>를 실행 컨텍스트가 관리하는 스코프에서 검색해서 취득한다.
3. 변수나 값의 변경 등 소스코드의 실행 결과는 다시 실행 컨텍스트가 관리하는 스코프에 등록된다.



### 실행 컨텍스트의 역할

**전역 코드 평가**

- 전역 코드를 실행하기 앞서 전역 코드 평가 과정을 거치며 전역 코드를 실행하기 위한 준비를 한다.
- 소스 코드 평가과정에서는 선언문만 먼저 실행한다.
  - 따라서 전역 코드의 변수 선언문과 함수 선언문이 먼저 실행된다.
  - 생성된 전역 변수와 전역 함수는 실행 컨텍스트가 관리하는 전역 스코프에 등록된다.
- 예를 들어 `var` 키워드로 선언된 전역 변수와 함수 선언문으로 정의된 전역 함수는 전역 객체의 프로퍼티와 메서드가 된다.



**전역 코드의 실행**

- 전역 코드 평가 과정이 끝나면 런타임이 시작되어 전역 코드가 순차적으로 실행되기 시작한다.
- 이때 전역 변수에 값이 할당되고 함수가 호출된다
- 함수가 호출되면 순차적으로 실행되던 전역 코드의 실행을 일시 중단하고 코드 실행 순서를 변경하여 함수 내부로 진입한다.



**함수 코드 평가**

- 함수 호출에 의해 코드 진행 순서가 변경되어 함수 내부로 진입하면, 함수 내부의 문들을 실행하기에 앞서 함수 코드 평가 과정을 거치며 함수 코들르 실행하기 위한 준비를 한다
- 매개변수와 지역 변수가 실행 컨텍스트가 관리하는 지역 스코프에 등록된다.
- 함수 내부에서 지역 변수처럼 사용할 수 있는 `argument` 객체가 생성되어 지역 스코프에 등록되고 `this 바인딩`도 결정된다.



**함수 코드의 실행**

- 함수 코드 평가 과정이 끝나면 런타임 이 실행되어 함수 코드가 순차적으로 실행되기 시작한다.
- 코드가 실행될 때 스코프를 구분하여 식별자와 바인딩 된 값이 관리되어야 한다.
  - 중첩 관계에 의해 스코프 체인을 형성하여 식별자를 검색할 수 있어야 한다.
  - 전역 객체의 프로퍼티도 전역 변수처럼 검색할 수 있어야 한다.



### 실행 컨텍스트는 소스코드를 실행하는 데 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역이다.

- 코드가 실행되려면 다음과 같이 스코프, 식별자, 코드 실행 순서 등의 관리가 필요하다.

  1. 선언에 의해 생성된 모든 식별자(변수, 함수, 클래스 등)를 스코프를 구분하여 등록하고 상태 변화(식별자에 바인딩 된 값의 변화)를 지속적으로 관리할 수 있어야 한다.

  2. 스코프는 중첩 관계에 의해 스코프 체인을 형성해야 한다. 즉, 스코프 체인을 통해 상위 스코프로 이동하며 식별자를 검색할 수 있어야 한다.
  3. 현재 실행 중인 코드의 실행 순서를 변경(예를들어, 함수 호출에 의한 실행 순서 변경)할 수 있어야 하며 다시 되돌아갈 수도 있어야 한다.



### 실행 컨텍스트와 렉시컬 환경

식별자와 스코프는 실행 컨텍스트의 **렉시컬 환경**으로 관리하고 코드 실행 순서는 **실행 컨텍스트 스택**으로 관리한다.



### 실행 컨텍스트 스택

실행 컨텍스트 스택의 최상위에 존재하는 실행 컨텍스트는 언제나 현재 실행중인 코드의 실행 컨텍스트 이다. 따라서 실행 컨텍스트 스택의 최상위에 존재하는 실행 컨텍스트를 **running execution context** 부른다.



### 렉시컬 환경(Lexical Environment)

렉시컬 환경은 식별자와 식별자에 바인딩 된 값, 그리고 상위 스코프에 대한 참조를 기록하는 자료구조로 실행 컨텍스트를 구성하는 컴포넌트다.

- 렉시컬 환경은 key-value 의 객체 형태의 스코프(전역, 함수, 블록 스코프)를 생성하여 식별자를 key로 등록하고 식별자에 바인딩된 값을 관리한다.
- 렉시컬 환경은 스코프를 구분하여 식별자를 등록하고 저장소 역할을 하는 렉시컬 스코프의 실체다.



**렉시컬 환경의 구성**

- 환경 레코드(Environment Record)
  - 스코프에 포함된 식별자를 등록하고 등록된 식별자에 바인딩된 값을 관리하는 저장소

- 외부 렉시컬 환경에 대한 참조(Outer LExical Environment Reference)
  - 외부 렉시컬 환경에 대한 참조는 상위 스코프를 가리킨다.
  - 외부 렉시컬 환경에 대한 참조를 통해 단방향 링크드 리스트인 스코프 체인을 구현한다.



## 느낀점

- 자바스크립트 딥 다이브 책을 실제 책으로 읽어가고 있는데, 기억하고 싶은 부분이나 인상 깊은 부분에 밑줄을 쳐가면서 읽는 편이다. 그 중 특히 이번 장은 반 정도를 형광펜으로 긋다시피 하며 읽었다.
- 공부를 하면서 헷깔렸기 때문이다. 자바스크립트에서 특징적인 부분을 설명할때 `실행 컨텍스트`라는 말은 계속 나오곤 했다.
- 완벽히 알았다고 단언할 정도까진 아니지만, 그래도 개념적으로 머릿속에 자리잡아가는 장 이었다.
- ~~그리고 내용이 많고 빡셌다..~~
- 지금은 빠르게 1회독 하면서 읽고 있지만, 다음에 시간을 갖으면서 천천히 읽게 되면 그땐 좀 더 흡수할 수 있지 않을까 기대된다.

